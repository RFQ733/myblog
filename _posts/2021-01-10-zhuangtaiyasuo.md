# 题目

算数之王

# 知识点

二进制搜索，二进制的运算



# 思路

这个题总结一下就是求方案数和最大的那个方案。每个方案是集合的两个sum相等的子集合。



求里面没有重叠的元素的两个相等的子集合，就能够搞出来这个题了。

如何搜索子集合一般来讲都是用二进制的特性来表示。（这里一会细说如何实现）

# 步骤

于是具体就分为两步

1，搜索出每一个子集合（我们用0表示未选取，1表示选取，这样就可以用一个0100100这样的一个01字符组（长度为n）来表示一个集合了）以及他们对应的集合的总和的值。（当然这里的01字符串不就是一个二进制的数吗，把他转为10进制就更容易在迭代的时候表示了）。

2，遍历每个集合 对于其他和它没有重叠元素的且值一样的集合 方案数++，并更新更新最大方案的值。



# 代码

~~~cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[11], val[2000];
bool fl[1000];
int main() {
	int t;
	cin >> t;
	while (t--) {
		int mx = 0, cnt = 0;
		cin >> n;
		for (int i = 0; i < n; i++)
			cin >> a[i];
		if (n <= 1) {
			cout << "0 0" << endl;
			continue;
		}
		memset(fl, 0, sizeof(fl));
		memset(val, 0, sizeof(val));
		int S = (1 << n) - 1;//所有子集的个数是2的n次方-1
        //
		for (int s = 0; s <= S; s++)
			for (int i = 0; i < n; i++) 
				//当s=1时 其二进制就是00000001，也就是说只有最后一位为1只选择最后一个数
                if (s >> i & 1)//二进制的移位和按位取和，emm简单来说就是当前第i位的数是不是1.
					val[s] += a[i];
		for (int s1 = 0; s1 <= S; s1++)
			int s2 = S ^ s1;//按位取或，就是上面说的防止有重复的元素。
			for (int ss2 = s2; ss2; ss2 = (ss2 - 1) & s2)//寻找下一个和该集合没有重叠元素的集合
				if (val[s1] == val[ss2]) {
					int x = val[s1];
					if (!fl[x]) {
						fl[x] = 1;
						mx = max(mx, x);
						cnt++;
					}
				}
		cout << cnt << ' ' << mx << endl;
	}
	return 0;
} 
~~~





